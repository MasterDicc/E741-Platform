//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⣾⣿⣷⣾⣿⣿⣿⣿⣶⣾⣿⣿⣶⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠉⢉⡽⢋⣙⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢰⣿⣦⣀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣛⣛⣓⣒⠶⢤⣾⠀⠀⠸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢸⣿⠳⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⡄⠀⠀⢳⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⣿⡦⠀⠀⠻⠿⣦⣀⡀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⡏⠀⠜⡴⠁⠀⠀⠀⡀⠀⠀⠉⠉⠲⢦⡀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⢠⣿⣷⡾⢿⣿⣿⣿⣿⣿⠿⢿⣿⣿⣿⣿⣿⡿⠛⠉⠁⠀⠀⣸⠀⠀⠀⢧⠀⠀⠀⠀⠹⠒⢤⣀⠀⠀⠁⠈⢢⠀
//⠀⠀⠀⠀⠀⠀⠀⠈⣿⣟⠀⠀⠈⠻⣿⠏⢨⠔⢦⠈⢻⣿⡼⠋⢀⣤⣶⣶⣿⣿⣿⣄⢠⣀⡜⠆⠀⢀⡠⠴⠒⠂⠈⢻⢦⡀⠀⠈⡇
//⠀⠀⢀⣶⣿⣷⠀⠀⠘⣿⡄⠀⠐⣶⢬⣇⠉⢣⡸⠀⣰⣿⣁⣴⣿⣿⣿⣿⣿⣿⣟⢿⣽⡛⣧⠔⠒⡏⣀⠀⠀⣀⣀⣾⠀⠑⠢⠤⠃
//⠀⣴⡟⣾⡟⣿⡇⣀⣼⣿⣿⣦⡀⠀⠙⠻⡆⠀⠇⢰⠟⠻⣿⣿⣿⣿⣿⡿⣿⣿⣿⣷⡿⠟⣇⠀⠀⢙⣰⣺⣽⣿⣿⣿⠀⠀⠀⠀⠀
//⢸⡿⢸⡿⣰⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⡴⠃⠀⠀⢸⡀⠀⢹⣿⣿⣿⣿⣿⢹⣿⣿⣯⣀⣀⣀⣭⣏⠁⠀⠀⠈⠻⣿⣿⠀⠀⠀⠀⠀
//⣿⡇⢸⡗⢸⠛⣿⡍⠉⠙⠛⠻⢭⣻⣿⣧⠀⠀⢀⣴⠷⣄⡀⠻⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⣿⡻⡆⠀⠀⠀⠀⠙⠇⠀⠀⠀⠀⠀
//⣿⡇⢸⣷⣽⠶⠛⢷⡀⣠⠤⢤⣾⣿⣿⣽⣞⣿⣭⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡙⢿⣿⠉⠛⢿⣿⣷⡇⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀
//⣿⣇⣼⢿⠁⠀⠀⢠⡷⡇⢠⣶⡽⣿⠋⠉⢻⠿⠛⠋⠉⠉⢹⠉⢻⢻⣿⣿⣿⣿⣿⣷⡶⢏⡠⠿⣿⣷⡞⠛⠙⢳⣦⡀⠀⠀⠀⠀⠀
//⣿⡏⢠⡋⣆⠀⠀⡞⠀⠇⠈⢿⣿⣏⠀⠀⠸⡀⠀⠀⠀⢀⡞⠀⢸⢸⣿⡏⠛⠛⠛⠉⣠⠋⣠⠀⠸⠧⢻⡝⢷⡄⢿⣷⠀⠀⠀⠀⠀
//⢸⣧⠸⡹⡌⢆⣴⣿⡀⠀⠀⠈⠻⠿⣆⠀⠀⠳⣄⣰⣚⠉⠉⠉⠻⣾⣿⡻⣦⣀⣠⣴⠷⠟⣻⠀⠀⠀⢸⡇⢸⣧⢨⣿⠀⠀⠀⠀⠀
//⠀⢿⣇⠓⠃⣼⣇⡈⠻⣄⠀⠰⢦⣀⢀⣷⡄⠀⠀⠀⠈⠉⠓⡤⣄⡈⡿⣿⣷⣶⣶⣶⣾⣿⠟⢀⠆⠀⡾⢷⣾⡇⣼⡟⠀⠀⠀⠀⠀
//⠀⠈⢿⢷⣞⠛⣿⣿⣤⡍⠳⣤⣤⣤⡿⠗⠁⠀⠀⠀⠀⠀⠀⠙⠀⠹⡅⠀⠈⠉⠉⠉⠻⣤⠔⠚⠒⠊⠀⠀⠈⣿⡿⠃⠀⠀⠀⠀⠀
// ███████ █████ ██   ██  ██⣤⣔⡊⣀⠀⠀⡷⠀⠀⠀⢀⣴⠞⠓⠲⠦⣤⡀⠀⠀⣠⡿⠁⠀⠀⠀⠀⠀⠀
// ██         ██ ██   ██ ███⠀⢹⠀⠙⣤⣃⣤⠶⠞⣫⣤⣟⣛⣷⣶⣿⢟⡦⣾⠟⠀⠀⠀⠀⠀⠀⠀⠀
// █████     ██  ███████  ██ ⢸⠀⠀⣿⡏⠾⠿⣶⣿⣿⣿⠿⣛⣽⣾⡿⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ██       ██        ██  ██ ⡇⠀⣠⠏⠉⠛⠳⠶⢶⣶⡿⠿⠟⠊⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ███████  ██        ██  ██⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

// A public demonstration in single-contract dual-token implementations
// with zero-conflict events, and function overloading.
// https://github.com/SJ741/E741-Platform
// https://741.gg   (Get the token telegram link from 'telegram' variable)
// Emerald Token Standard

// WARNING - Fungible NFT specs are universally new, and inherently DANGEROUS
// no systems have been built with these usecases in mind, and there are a number of 
// ways that experimental, complex contracts can lead to unforseen consequences.
// INTERACT WITH EXPERIMENTAL SMART CONTRACTS AT YOUR OWN RISK

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import './E741V1Base.sol';

contract E741V1Wrapped741 is E741V1Base {

    event Deposit(address indexed from, uint amount741Out, uint[] amounts741In);
    event Withdrawal(address indexed to, uint amountUnderlyingOut, uint[] amounts741In);

    address constant EMERALDS = 0x382EDfe4c6168858C81893fE00fCB7b68914d929;
    address public underlying741;
    uint public underlyingWeiPerNft;

    address public feeRecipient;
    uint public withdrawalFees;
    uint internal withdrawalFeesDivisor = 10000;
    uint constant WITHDRAWAL_FEES_MIN = 5; // 0.05%
    uint constant WITHDRAWAL_FEES_MAX = 50; // 0.5%

    function initialize(bytes memory encodedParameters) public virtual override returns (address) {
        require(_decimals == 0, "Already initialized");
        
        {
            // to prevent stack to deep error
            string memory _inputName; 
            string memory _inputSymbol;
            (withdrawalFees, underlying741, _inputName, _inputSymbol, _decimals, baseURI, _contractURI, _totalIds, underlyingWeiPerNft) = 
                abi.decode(encodedParameters, (uint,address,string,string,uint,string,string,uint,uint));

            _name = _inputName;
            _symbol = _inputSymbol;
        }

        {
            address _token = underlying741;
            require(_token != address(0), 'E741V1: ZERO_ADDRESS');
            try IERC165(_token).supportsInterface(0x5a46575f) returns (bool supports741) {
                require(_token == EMERALDS || supports741, "The underlying token does not support e741");
            } catch {
                revert("The underlying token does not support ERC165");
            }
        }

        ONE = 10 ** _decimals;
        MAXID = ONE + _totalIds - 1;
        minted = uint64(ONE) - 1; // start minting from ID ONE-1 so you can get id 0

        feeRecipient = msg.sender; // our factory is always the fee recipient even if dev of token changes

        require(_decimals <= 18 && IERC20(underlying741).decimals() <= 18, "Too many decimals");
        require(_totalIds > 0, "Need at least 1 nft");
        require(withdrawalFees >= WITHDRAWAL_FEES_MIN, "Min fees of 0.05%");
        require(withdrawalFees <= WITHDRAWAL_FEES_MAX, "Max fees of 0.5%");
        require(ONE > _totalIds, "Not enough decimals for NFT count");

        return underlying741;
    }


    // deposit amount of underlying741
    function deposit(uint[] memory _amountsArray) public virtual override {

        uint _len = _amountsArray.length;
        uint _amount741Out;
        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();

        if(_len == 1) {
            if(IE741(underlying741).ownerOf(_amountsArray[0]) != msg.sender) { // not single nft transfer
                _amount741Out = (_amountsArray[0] * ONE) / underlyingWeiPerNft;
            }
            else {
                _amount741Out = (_underlyingONE * ONE) / underlyingWeiPerNft; // _len is 1
            }            
            // use direct from array to transfer the nft id if used
            IE741(underlying741).transferFrom(msg.sender, address(this), _amountsArray[0]);
        }
        else {
            for(uint i = 0; i < _len; i++) {
                // reverts if they deposit unowned or invalid id
                IE741(underlying741).safeTransferFrom(msg.sender, address(this), _amountsArray[i]);
            }
            _amount741Out = ((_len * _underlyingONE) * ONE) / underlyingWeiPerNft;
        }
        // spawn raw tokens
        _balanceOf[DEPOSIT_ADDRESS] += _amount741Out;

        _totalSupply += _amount741Out;

        _transfer741(DEPOSIT_ADDRESS, msg.sender, _amount741Out); // use _transfer741 to give user broken nfts if necessary

        // donating tokens to this wrapper will only make the wrapped token more scarce
        require(underlyingWeiPerNft * _totalIds >=  IERC20(underlying741).balanceOf(address(this)), "NFT capacity reached, wait for someone to withdraw");

        emit Deposit(msg.sender, _amount741Out, _amountsArray);
    }

    // Two modes
    // withdraw([amount])
    // withdraw([id1, id2, id3])
    function withdraw(uint256[] memory _amountsArray741) public virtual override payable {
        uint _arrayLen = _amountsArray741.length;
        require(_arrayLen > 0, "Trying to withdraw nothing");

        uint _amount741; uint _amount741Sum;
        uint _underlyingONE = 10 ** IERC20(underlying741).decimals();

        if (_arrayLen == 1) {
            _amount741 = _amountsArray741[0];
            if (ownerOf[_amount741] == msg.sender) {
                _amount741Sum = ONE; // only record ONE for owned transfer
            } else {
                _amount741Sum = _amount741;
            }
            transfer(DEPOSIT_ADDRESS, _amount741);
        } else {
            for(uint i = 0; i < _arrayLen;) {
                _amount741 = _amountsArray741[i];
                require(ownerOf[_amount741] == msg.sender, "Can only withdraw for nfts you own");
                transfer(DEPOSIT_ADDRESS, _amount741);
                unchecked { i++; }
            }
            _amount741Sum = _arrayLen * ONE; // only record ONE for owned transfer
        }
        // remove raw tokens
        _balanceOf[DEPOSIT_ADDRESS] -= _amount741Sum;
        _totalSupply -= _amount741Sum;

        uint _totalUnderlyingOut = (_amount741Sum * underlyingWeiPerNft) / ONE; // use ONE not _underlyingONE
        uint _totalUnderlyingFees = (_totalUnderlyingOut * withdrawalFees) / withdrawalFeesDivisor;

        IE741(underlying741).transfer(feeRecipient, _totalUnderlyingFees);
        
        IE741(underlying741).transfer(msg.sender, (_totalUnderlyingOut - _totalUnderlyingFees));

        emit Withdrawal(msg.sender, _totalUnderlyingOut, _amountsArray741);
    }
}